// The goal of this program is to draw two objects
// Each uses the same shader pair and meshes, but different model matrices and colors

// Some kinda metaprogramming
with type T:
declare type varying;

mat4 uModel;
mat4 uView;
mat4 uProjection;

// All functions must have a target language; this one is typescript
typescript void main() {
    // compiling a program recovers its member variables statically
    // the set of writeable member variables of a program are as follows (U = union):
    // { in(VERTEX) } U { uniform(VERTEX) } U { uniform(FRAGMENT) }
    // the set of readable member variables of a program are the out variable of FRAGMENT
    // We can't yet write or read these these variables
    object_program = glsl_compile(vertex, fragment);
    shadow_program = glsl_compile(shadow_vertex, shadow_fragment);
    ...

    mesh1 = ...;
    mesh2 = ...;


    model1 = mat4.create();
    mat4.translate(model1, model1, [10., 10., 10.]);
    model2 = mat4.create();
    mat4.translate(model2, model2, [-10., -10., -10.]);

    while (true) {
        render(object_program, shadow_program, mesh1, mesh2, get_view(), get_projection(), model1, model2);
    }

}

typescript void render(object_program, shadow_program, mesh1, mesh2, view, projection, model1, model2) {

    function buildShadowBuffers(mesh: lgl.Mesh, model: mat4) {
        gl.uniformMatrix4fv(shadowLocations["uModel"], false, model);
        lgl.bind_attrib_buffer(gl, shadowLocations["aPosition"] as number, mesh.positions, 3);
        lgl.bind_element_buffer(gl, mesh.cells);

        gl.drawElements(gl.TRIANGLES, mesh.cell_count, gl.UNSIGNED_SHORT, 0);
        let errorCode = gl.getError();
        if (errorCode != 0) {
            throw errorCode;
        }
    }

    with shadow_program {
        let shadowFramebuffer = gl.createFramebuffer();
        let shadowDepthTexture = gl.createTexture();
        let renderBuffer = gl.createRenderbuffer();

        ... // Set up the above buffers

        bind shadowFramebuffer to gl.FRAMEBUFFER,
            shadowDepthTexture to gl.TEXTURE_2D,
            renderBuffer to gl.RENDERBUFFER {

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            buildShadowBuffers(mesh1, model1);
            buildShadowBuffers(mesh2, model2);

            let width = gl.drawingBufferWidth;
            let height = gl.drawingBufferHeight;
            gl.viewport(0, 0, width, height);
            gl.clearColor(0., 0., 0., 0.);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
    }

    with object_program.vertex as vertex{
        bind view to uView,
             projection to uProjection,
             mesh.positions to vertex.vPosition,
             [1, 0, 1] to color {

            bind model1 to uModel {
                vertex(object_program);
            }
            bind model2 to uModel {
                vertex(object_program);
            }
        }
    }
}

program vertex() {
    in vec3 vPosition;
    in sampler2D shadowmap;
    in vec2 uv;
    out vec3 vColor;

    void main(object_program) {
        vColor = color;
        gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.);

        with object_program.fragment as fragment{
            bind vPosition to fragment.vPosition,
                shadowmap to fragment.shadowmap,
                uv to fragment.uv {

                object_program.fragment();
            }
        }
    }
}

program fragment() {
    in vec3 vPosition;
    in sampler2D shadowmap;
    in vec2 uv;
    out vec4 gl_FragColor;

    void main() {
        ...
        gl_FragColor = ...;
        
        draw();
    }
}