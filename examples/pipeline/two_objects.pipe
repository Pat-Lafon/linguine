using "../opengl";

// The goal of this program is to draw two objects
// Each uses the same shader pair and meshes, but different model matrices and colors

// Some kinda metaprogramming
with type T:
declare type varying;

binding mat4 uModel;
binding mat4 uView;
binding mat4 uProjection;

// All functions must have a target language; this one is typescript
typescript void main() {
    // compiling a program recovers its member variables statically
    // the set of readable member variables of a program are the out variable of FRAGMENT
    // We can't yet write or read to these variables


    // glsl_compile takes in (graphics) descriptors for gpu code. Spits out a compiled program that needs to have it's initial values bound and called to render
    program = glsl_compile(vertex(fragment));

    ...
    model1 = mat4.create();
    mat4.translate(model1, model1, [10., 10., 10.]);
    model2 = mat4.create();
    mat4.translate(model2, model2, [-10., -10., -10.]);
    while (true) {
        render(program, get_mesh(), get_view(), get_projection());
    }
}

typescript void render(program, mesh, view, projection) {
    vertex = program.vertex;
    // Binds the current program (restricted to a value)
    model1;
    model2;
    with vertex {
        bind view to uView and projection to uProjection {
            bind mesh to vertex.aPosition {
                bind model1 to uModel {
                    // the ready function checks that all inputs have been initialized
                    vertex.ready();
                    // Actually run the program
                    // Calls the main function of vertex
                    program.run(...);
                }
                bind model2 to uModel {
                    vertex.ready();
                    program.run(...);
                }
            }
        }
    }
}

@param aPosition:vec3[][] -> vec3
parallel vertex {
    in vec3 aPosition;
    in vec3 uColor;
    out vec4 gl_Position;
    void main(fragment) {
        vec3 pos = vec3(uView * uModel * vec4(aPosition, 1.));
        with fragment {
            bind pos to fragment.vPosition {
                // ready check is static and isn't run
                fragment.ready();
            }
        }
        gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.);
    }
}

program fragment {
    in vec3 vPosition;
    out vec4 gl_FragColor;
    void main() {
        gl_FragColor = vPosition;
    }
}