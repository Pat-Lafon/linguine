using "opengl";

// The goal of this program is to draw two objects
// Each uses the same shader pair and meshes, but different model matrices and colors

// Some kinda metaprogramming
with type T:
declare type varying;

binding mat4 uModel;
binding mat4 uView;
binding mat4 uProjection;

// All functions must have a target language; this one is typescript
typescript void main() {
    // compiling a program recovers its member variables statically
    // the set of readable member variables of a program are the out variable of FRAGMENT
    // We can't yet write or read to these variables


    // glsl_compile takes in (graphics) descriptors for gpu code. Spits out a compiled program that needs to have it's initial values bound and called to render
    program = glsl_compile(vertex, fragment, draw);
    // Rely on glsl_compile checking the bounds of our program

    ...
    model1 = mat4.create();
    mat4.translate(model1, model1, [10., 10., 10.]);
    model2 = mat4.create();
    mat4.translate(model2, model2, [-10., -10., -10.]);
    while (true) {
        render(program, get_mesh(), get_view(), get_projection());
    }
}

typescript void render(program, mesh, view, projection) {
    // Binds the current program (restricted to a value)
    model1;
    model2;
    with program {
        // before we called program.run(...)?
        // Maybe we want to pipe/send the output of run() to draw?
        bind view to uView and projection to uProjection {
            bind mesh to program.aPosition, [1.0, 0.0, 0.0] to uColor {
                bind model1 to uModel {
                    program.run();
                }
                bind model2 to uModel {
                    program.run();
                }
            }
        }
    }
}


@attribute aPosition
@uniform uColor
@constant<gl_VertexID> gl_VertexID
program vertex : VERTEX {
    in int gl_VertexID
    in vec3 aPosition;
    in vec3 uColor;
    out vec3 vPosition
    out vec4 gl_Position;
    void main() { // main<fragment>()
        vec3 vPosition = vec3(uView * uModel * vec4(aPosition, 1.));
        gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.);
        //with fragment {
        //    ....
        //    fragment()
        //}
    }
}

program fragment : FRAGMENT {
    in vec3 vPosition;
    out vec4 gl_FragColor;
    void main() {
        gl_FragColor = vPosition;
    }
}